package patterns.GoF.behavioral.strategy;

abstract class AudiCar {

    /* 1.
    Паттерн Стратегия – один из самых простых поведенческих шаблонов проектирования, предназначенный для определения семейства алгоритмов,
    инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
    Это позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.

    Реализация: допустим, нам необходимо написать программу для только что открывшегося автозавода.
    Заказчик пока собирается выпускать только одну модель машин и необходима программа, для хранения характеристик этой модели.
    Пусть это будет переднеприводный седан.
    Создадим два класса один абстрактный – Car с одним методом — void drive(),
    второй класс – AudiA3, который описывает единственную модель автомобиля завода.

    public void drive(){
        System.out.println("All cars can drive!");  }

    автоконцерн решает наладить выпуск новой модели – полноприводного седана.
    придется изменять программу, самый простой и очевидный вариант: сделать метод void drive() абстрактным
    и реализовать его в классах конкретных моделей.

    abstract public void drive();

Вроде неплохо. Вот только ходят слухи, что разрабатывается прототип машины с отключаемым полным приводом.
Это уже большая проблема, если мы и дальше будем следовать подобному шаблону, то потеряем гибкость  программы
и запутаемся в огромном количестве классов машин с разной комплектацией. Приступим к рефакторингу.
Воспользуемся двумя фундаментальными принципами проектирования,
первый – выделить аспекты приложения, которые могут измениться и отделить их от тех, которые всегда остаются постоянными;
второй – программировать на уровне интерфейсов (супертипов), а не на уровне реализаций.

Изменяется у нас метод void drive(), с него и начнем и создадим интерфейс Drivable c двумя классами RearWheelDrive и FullWheelDrive,
которые его реализуют: один для полноприводных машин, второй для переднеприводных.

     */

    private Drivable drivable;

    public void performDrive(){
        drivable.drive();
    }

    /*Вернемся к машинам с отключаемым полным приводом.
    При нашей переработанной архитектуре приложения это будет легко реализовать с помощью метода сеттера,
    который мы добавим в наш главный класс AudiCar, заодно улучшим инкапсуляцию сделав переменную drivable приватной.
И немного изменим реализацию классов конкретных моделей машин
Теперь мы можем изменять поведение нашей машины на ходу
     */
    public void setDrivable(Drivable drivable){
        this.drivable = drivable;
    }

}
