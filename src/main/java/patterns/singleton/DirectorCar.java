package patterns.singleton;

public class DirectorCar {
    /*Часто в системе могут существовать сущности только в единственном экземпляре,
     например, система ведения системного журнала сообщений или драйвер дисплея.
    Паттерн Одиночка – порождающий паттерн проектирования, гарантирующий, что в однопоточном приложении будет единственный
    экземпляр класса с глобальной точкой доступа.
    Реализация: паттерн чрезвычайно прост, попробуем с его помощью создать машину для директора, кот. будет существовать в единственном экземпляре.
    1) Создание приватного конструктора в классе позволит избежать создание одиночки другими классами,
    2) вторым шагом будет создание метода получения экземпляра класса.

    3) В клиентском кодек заменить ывзовы конструктора одиночки на методы вызывающие его создание.

     */

    private static DirectorCar directorCar = new DirectorCar(); // приватное статическое поле, которое будет содержать одиночный объект
    // если многопоточное приложение, то Первое изменение это – переменная presidentCar в ее объявлении теперь присутствует ключевое слово
    // volatile, оно гарантирует, что параллельные потоки будут корректно с ней работать;
    // private volatile static DirectorCar directorCar = new DirectorCar();

    private int armor;

    private DirectorCar(){                    // приватный конструктор. Здесь м.б. и приватный конструктор ПО УМОЛЧАНИЮ.
        this.armor = 120;
    }

    public static DirectorCar getInstance(){  // метод получения экземпляра класса.
        // Публичный статический метод, кот. будет контролировать жизненный цикл объекта одиночки
        return directorCar;
    }
    /*!!! если у нас есть необходимость в нескольких потоках! двойная проверка, если экземпляр класса не существует,
    то происходит вход в блок synchronized, другими словами синхронизация выполняется только при первом вызове,
     внутри этого блока снова проверяется создан ли экземпляр класса, если нет, то он создается.
     Для чего это сделано – синхронизация сама по себе очень затратная операция с точки зрения системных ресурсов
     и использовать ее при каждом вызове экземпляра класса нецелесообразно.

         public static DirectorCar getInstance(){
        if(directorCar == null){
            synchronized (DirectorCar.class){  //-- блок кода, который подлежит синхронизации
                if(directorCar == null){
                    directorCar = new DirectorCar();
                }
            }
        }
        return directorCar;
    }
         */



    public int getArmor(){
        return armor;
    }

    public void setArmor(int armor){
        this.armor = armor;
    }

  /*  В классе две переменных: ссылка на сам объект класса (directorCar) и переменная для хранения информации о бронировании машины.
  Для того, чтобы объект класса нельзя было создать из вне, конструктор класса был сделан приватным,
  в конструкторе задается начальное значение бронирования автомобиля в 120 мм.
  Для получения ссылки на объект используется статичный метод getInstance().
  Два оставшихся метода getArmor() и setArmor(int armor) используются для получения информации о бронировании машины и ее изменении.
  В некоторых источниках рекомендуется для переменной экземпляра класса (directorCar) использовать модификатор final.
  */

}


/*Теперь к примерам.
- DirectX. Для работы с графикой тебе необходимо по одной инстанции интерфейсов IDirect3D и IDirect3DDevice.
 Эти две инстанции декларируют глобальное состояние программы. Инстанции всех буферов, текстур, шейдеров и поверхностей
  создаются с использованием этих инстанций. Разумным будет предоставить доступ к инстанциям DirectX через подход синглтона.
- OpenGL старых добрых версий. Процедурный интерфейс OpenGL как бы намекает на отсутствие необходимости в глобальном состоянии.
Но не тут то было. Для работы с OpenGL необходимо не просто создать контекст, но еще и помнить поток, в котором этот контекст
связан с поверхностью вывода. В многопоточной среде контекстов может быть несколько для параллельной загрузки ресурсов.
В этом случае помнить надо уже два потока и два контекста (минимум). Само собой, в синглтоне это глобальное состояние смотрится удобнее.
- Sockets. Не важно какие. Когда твое приложение представляет собой MMO проект и у тебя гора подсистем, постоянно
и обособленно общающихся с сервером,

сетевое подключение разумно оформить в виде синглтона.

- Assets/Resources - они бывают разные, кешируемые и нет, доступные из сети, с жесткого диска, из подсистемы пререндеринга.
 Опять же, я несколько раз видел боль и страдания от неоднородного контроля ресурсов без соответствующей подсистемы.
 А сама подсистема управления ресурсами всегда централизована и лучше всего реализуется именно на синглтоне. */